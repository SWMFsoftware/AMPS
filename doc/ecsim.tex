%=========================================================
% AMPS PIC/ECSIM solver analysis (LaTeX-ready writeup)
%=========================================================

\newpage
\section{AMPS PIC Electromagnetic Field Solver (ECSIM): Code-Level Analysis}

This section summarizes the structure of the AMPS implicit electromagnetic PIC field solve (ECSIM) as implemented in the uploaded sources (\texttt{pic\_field\_solver\_ecsim.cpp}, \texttt{get\_stencil.cpp}, \texttt{update\_rhs.cpp}, \texttt{LinearSystemCornerNode.h}, \texttt{pic.h}).

\subsection{What the linear system solves for: an increment \texorpdfstring{$\Delta \mathbf{E}$}{ΔE}}
The linear solver is formulated for an \emph{increment} rather than the absolute field:
\begin{equation}
\Delta \mathbf{E} \;\equiv\; \mathbf{E}^{n+\theta} - \mathbf{E}^{n}.
\end{equation}
After solving, the half-step electric field is reconstructed as
\begin{equation}
\mathbf{E}^{n+\theta} \;=\; \mathbf{E}^{n} \;+\; \frac{\mathbf{x}}{E_{\mathrm{conv}}},
\end{equation}
where $\mathbf{x}$ is the raw solver solution vector stored per corner node (3 unknowns per corner), and $E_{\mathrm{conv}}$ is the electric-field conversion factor. In this formulation, field boundary conditions are naturally imposed as
\begin{equation}
\Delta \mathbf{E}\big|_{\partial\Omega} = \mathbf{0}.
\end{equation}

\subsection{Time-step pipeline in \texttt{ECSIM::TimeStep()}}
A typical time step follows:

\begin{enumerate}
\item \textbf{Update particle moments for the implicit solve:}
\begin{itemize}
\item Compute the implicit-current predictor $\hat{\mathbf{J}}$ on corner nodes.
\item Accumulate/store the \textbf{mass matrix} coefficients $M$ on corner nodes (packed in a block-local buffer layout).
\end{itemize}

\item \textbf{Assemble/update the linear system matrix:}
\begin{itemize}
\item When needed, build the sparsity pattern (stencil connectivity).
\item Each time step, update matrix values using a decomposition into:
\begin{equation}
A_{ij} \;=\; A^{(\mathrm{param})}_{ij} \;+\; \left(4\pi\,\Delta t\,\theta\right)\,A^{(\mathrm{mm})}_{ij},
\end{equation}
where $A^{(\mathrm{mm})}_{ij}$ references mass-matrix entries via pointer-based ``support tables'' (one support entry per neighbor/component coupling).
\end{itemize}

\item \textbf{Assemble the RHS:} evaluate a sum of \emph{semantic} support contributions (corner and center samples) of the form
\begin{equation}
\mathrm{rhs} \;\leftarrow\; \mathrm{rhs} \;+\; \sum_{s\in\mathcal{S}} \alpha_s\, \mathcal{Q}_s,
\end{equation}
where each support entry $s$ encodes: (i) a quantity type (e.g., $\mathbf{E}$, $\mathbf{B}$, $\hat{\mathbf{J}}$, mass matrix, etc.), (ii) where to sample it (corner/center node + offsets), and (iii) a coefficient $\alpha_s$.

\item \textbf{Solve for $\Delta\mathbf{E}$:} 3 unknowns per corner node.

\item \textbf{Update magnetic field:} advance $\mathbf{B}$ using Faraday's law with $\mathbf{E}^{n+\theta}$.

\item \textbf{Convert $\mathbf{E}^{n+\theta}\rightarrow \mathbf{E}^{n+1}$:}
\begin{equation}
\mathbf{E}^{n+1} \;=\; \frac{\mathbf{E}^{n+\theta} - (1-\theta)\mathbf{E}^{n}}{\theta}.
\end{equation}

\item \textbf{Apply boundary conditions / exchange halos} as appropriate.
\end{enumerate}

\subsection{Stencil/operator structure constructed by \texttt{GetStencil()}}
For each component row $iVar\in\{x,y,z\}$ at a corner $(i,j,k)$, the stencil includes:

\paragraph{(i) Curl--curl operator via the identity}
The code constructs the vector operator using
\begin{equation}
\nabla\times\nabla\times \mathbf{E} \;=\; \nabla(\nabla\cdot\mathbf{E}) \;-\; \nabla^2\mathbf{E}.
\end{equation}
This appears in the implementation as the sum of a ``minus Laplacian'' block and a ``plus grad--div'' block.

\paragraph{(ii) Identity term for the increment formulation}
The diagonal (self) entry is explicitly incremented by $+1$, corresponding to the $I\,\Delta\mathbf{E}$ part of the linear system.

\paragraph{(iii) Mass-matrix coupling in the LHS}
The stencil includes couplings to up to $3\times 3\times 3$ corner-node neighbors and all vector components (up to 81 couplings per row block), whose values are computed as
\begin{equation}
A_{ij}^{(\mathrm{mm})} \;=\; (4\pi\,\Delta t\,\theta)\,M_{ij},
\end{equation}
with $M_{ij}$ stored in packed buffers and accessed through a precomputed offset table.

\subsection{RHS anatomy and a key consistency check (unit conversion)}
Because the unknown is $\Delta\mathbf{E}$, any implicit term containing $M\mathbf{E}^{n+\theta}$ expands as
\begin{equation}
M\mathbf{E}^{n+\theta} \;=\; M(\mathbf{E}^{n}+\Delta\mathbf{E}) \;=\; M\mathbf{E}^{n} \;+\; M\Delta\mathbf{E}.
\end{equation}
Thus, $M\Delta\mathbf{E}$ belongs on the LHS, while $M\mathbf{E}^n$ must appear on the RHS with the appropriate sign.

\medskip
\noindent\textbf{Important implementation consistency check:} the legacy RHS path explicitly applies field conversion factors (e.g., $E_{\mathrm{conv}}$, $B_{\mathrm{conv}}$) to samples. In the newer semantic RHS path, the conversions must be applied \emph{either} inside the sampling routine \emph{or} folded into the stencil coefficients; otherwise the semantic RHS may not be numerically equivalent to the legacy formulation when $E_{\mathrm{conv}}$ or $B_{\mathrm{conv}}$ differ from unity.

\subsection{Boundary conditions}
Boundary rows are short-circuited to enforce
\begin{equation}
\Delta \mathbf{E} = \mathbf{0}
\end{equation}
(by setting a unit diagonal and removing couplings/supports), which is consistent with the increment formulation.


%=========================================================
% Focused “physics ↔ discretization” derivation (LaTeX)
%=========================================================

\section{Focused Physics $\leftrightarrow$ Discretization Derivation (ECSIM Increment Form)}

\subsection{Continuous equations (Gaussian units, as suggested by $4\pi$ factors)}
Consider Maxwell's equations (neglecting charge conservation details here since the field solve is written in terms of $\mathbf{E}$ and $\mathbf{B}$):
\begin{align}
\frac{\partial \mathbf{B}}{\partial t} &= -c\,\nabla\times \mathbf{E}, \label{eq:faraday}\\
\frac{\partial \mathbf{E}}{\partial t} &= c\,\nabla\times \mathbf{B} - 4\pi\,\mathbf{J}. \label{eq:ampere}
\end{align}
ECSIM introduces a \emph{linearized implicit current response} at the field-solve time level,
\begin{equation}
\mathbf{J}^{n+\theta} \;\approx\; \hat{\mathbf{J}}^{\,n} \;+\; M\,\mathbf{E}^{n+\theta},
\label{eq:implicit_current_model}
\end{equation}
where
\begin{itemize}
\item $\hat{\mathbf{J}}^{\,n}$ is a predicted current (independent of $\mathbf{E}^{n+\theta}$),
\item $M$ is the (sparse) mass matrix constructed from particle data and shape functions.
\end{itemize}

\subsection{Temporal discretization with a $\theta$-scheme}
Define the intermediate (implicit) time level
\begin{equation}
\mathbf{E}^{n+\theta} \;=\; (1-\theta)\mathbf{E}^n + \theta \mathbf{E}^{n+1},\qquad
\mathbf{B}^{n+\theta} \;=\; (1-\theta)\mathbf{B}^n + \theta \mathbf{B}^{n+1}.
\end{equation}
Discretize Faraday \eqref{eq:faraday} using $\mathbf{E}^{n+\theta}$:
\begin{equation}
\mathbf{B}^{n+1} \;=\; \mathbf{B}^n \;-\; c\,\Delta t \,\nabla\times \mathbf{E}^{n+\theta}.
\label{eq:B_update_theta}
\end{equation}
Discretize Amp\`ere \eqref{eq:ampere} using $\mathbf{B}^{n+\theta}$ and $\mathbf{J}^{n+\theta}$:
\begin{equation}
\mathbf{E}^{n+1} \;=\; \mathbf{E}^n \;+\; \Delta t \left(c\,\nabla\times \mathbf{B}^{n+\theta} \;-\; 4\pi\,\mathbf{J}^{n+\theta}\right).
\label{eq:E_update_theta}
\end{equation}
Insert the implicit current model \eqref{eq:implicit_current_model}:
\begin{equation}
\mathbf{E}^{n+1} \;=\; \mathbf{E}^n \;+\; \Delta t \left(c\,\nabla\times \mathbf{B}^{n+\theta} \;-\; 4\pi\,\hat{\mathbf{J}}^{\,n} \;-\; 4\pi\,M\,\mathbf{E}^{n+\theta}\right).
\label{eq:E_update_theta_with_M}
\end{equation}

\subsection{Eliminate $\mathbf{B}^{n+\theta}$ to obtain a single equation for $\mathbf{E}^{n+\theta}$}
From \eqref{eq:B_update_theta}:
\begin{equation}
\mathbf{B}^{n+\theta} \;=\; \mathbf{B}^n \;-\; \theta\,c\,\Delta t \,\nabla\times \mathbf{E}^{n+\theta}.
\label{eq:B_n_theta_in_terms_of_E}
\end{equation}
Substitute \eqref{eq:B_n_theta_in_terms_of_E} into \eqref{eq:E_update_theta_with_M}:
\begin{align}
\mathbf{E}^{n+1}
&= \mathbf{E}^n + \Delta t \left(
c\,\nabla\times\Big[\mathbf{B}^n - \theta c\Delta t \nabla\times \mathbf{E}^{n+\theta}\Big]
-4\pi \hat{\mathbf{J}}^{\,n} - 4\pi M \mathbf{E}^{n+\theta}
\right) \nonumber \\
&= \mathbf{E}^n + c\Delta t \,\nabla\times \mathbf{B}^n
- \theta (c\Delta t)^2 \,\nabla\times\nabla\times \mathbf{E}^{n+\theta}
-4\pi\Delta t\,\hat{\mathbf{J}}^{\,n}
-4\pi\Delta t\,M\mathbf{E}^{n+\theta}.
\label{eq:E_nplus1_expanded}
\end{align}
Now use the definition of $\mathbf{E}^{n+\theta}$:
\begin{equation}
\mathbf{E}^{n+1} \;=\; \frac{1}{\theta}\mathbf{E}^{n+\theta} \;-\; \frac{1-\theta}{\theta}\mathbf{E}^n.
\label{eq:E_nplus1_from_En_theta}
\end{equation}
Substitute \eqref{eq:E_nplus1_from_En_theta} into \eqref{eq:E_nplus1_expanded} and multiply by $\theta$ to isolate $\mathbf{E}^{n+\theta}$:
\begin{align}
\mathbf{E}^{n+\theta}
&= \mathbf{E}^n + \theta c\Delta t \,\nabla\times \mathbf{B}^n
- \theta^2 (c\Delta t)^2 \,\nabla\times\nabla\times \mathbf{E}^{n+\theta}
-4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}
-4\pi\theta\Delta t\,M\mathbf{E}^{n+\theta}.
\end{align}
Bring all $\mathbf{E}^{n+\theta}$-terms to the LHS:
\begin{equation}
\Big[I \;+\; \theta^2(c\Delta t)^2\,\nabla\times\nabla\times \;+\; 4\pi\theta\Delta t\,M\Big]\mathbf{E}^{n+\theta}
\;=\;
\mathbf{E}^n \;+\; \theta c\Delta t\,\nabla\times\mathbf{B}^n \;-\; 4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}.
\label{eq:field_equation_for_En_theta}
\end{equation}
\textbf{Note:} depending on sign conventions for $\nabla\times\nabla\times$ in the discrete operator (some codes implement it as $-\nabla^2+\nabla\nabla\cdot$ with explicit minus signs in coefficients), the assembled stencil may implement the equivalent operator with opposite internal sign. The safest equivalence statement is that the code assembles the standard curl--curl operator using
\begin{equation}
\nabla\times\nabla\times \mathbf{E} = \nabla(\nabla\cdot\mathbf{E})-\nabla^2\mathbf{E},
\end{equation}
and multiplies it by $(\theta c\Delta t)^2$ (up to the code's discrete sign convention).

\subsection{Increment form used in AMPS: $\mathbf{E}^{n+\theta}=\mathbf{E}^n+\Delta\mathbf{E}$}
Define $\Delta\mathbf{E}=\mathbf{E}^{n+\theta}-\mathbf{E}^n$ so that
\begin{equation}
\mathbf{E}^{n+\theta}=\mathbf{E}^n+\Delta\mathbf{E}.
\end{equation}
Insert into \eqref{eq:field_equation_for_En_theta}:
\begin{equation}
\Big[I + \theta^2(c\Delta t)^2\,\nabla\times\nabla\times + 4\pi\theta\Delta t\,M\Big](\mathbf{E}^n+\Delta\mathbf{E})
=
\mathbf{E}^n + \theta c\Delta t\,\nabla\times\mathbf{B}^n - 4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}.
\end{equation}
Rearrange to obtain the linear system for $\Delta\mathbf{E}$:
\begin{equation}
\underbrace{\Big[I + \theta^2(c\Delta t)^2\,\nabla\times\nabla\times + 4\pi\theta\Delta t\,M\Big]}_{\mathcal{A}}
\Delta\mathbf{E}
=
\underbrace{\theta c\Delta t\,\nabla\times\mathbf{B}^n - 4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}
- \theta^2(c\Delta t)^2\,\nabla\times\nabla\times \mathbf{E}^n
- 4\pi\theta\Delta t\,M\mathbf{E}^n}_{\mathbf{b}}.
\label{eq:increment_linear_system}
\end{equation}
This is the \textbf{physics $\leftrightarrow$ discretization} mapping:
\begin{itemize}
\item $I\,\Delta\mathbf{E}$ $\leftrightarrow$ diagonal ``$+1$'' identity term in the stencil.
\item $(\theta c\Delta t)^2\,\nabla\times\nabla\times\Delta\mathbf{E}$ $\leftrightarrow$ curl--curl assembled as ``$-\nabla^2+\nabla\nabla\cdot$'' (Laplacian + grad--div blocks).
\item $4\pi\theta\Delta t\,M\Delta\mathbf{E}$ $\leftrightarrow$ mass-matrix neighbor/component couplings in the LHS matrix.
\item $\theta c\Delta t\,\nabla\times\mathbf{B}^n$ $\leftrightarrow$ center-node $\mathbf{B}$ samples contributing to RHS.
\item $-4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}$ $\leftrightarrow$ corner-node predicted current in RHS.
\item $-(\theta c\Delta t)^2\,\nabla\times\nabla\times\mathbf{E}^n$ $\leftrightarrow$ explicit curl--curl of the old field moved to RHS.
\item $-4\pi\theta\Delta t\,M\mathbf{E}^n$ $\leftrightarrow$ the old-field mass-matrix dot-product moved to RHS.
\end{itemize}

\subsection{Discrete operator as implemented (stencil form)}
On a corner-node grid, each row corresponds to one component (say $\Delta E_x$ at node $p$). The discrete equation is:
\begin{equation}
\sum_{q\in\mathcal{N}(p)} \sum_{\beta\in\{x,y,z\}}
\Big[
\underbrace{K^{(\mathrm{curlcurl})}_{p\alpha,q\beta}}_{\text{from }(\theta c\Delta t)^2\nabla\times\nabla\times}
\;+\;
\underbrace{4\pi\theta\Delta t\,M_{p\alpha,q\beta}}_{\text{mass matrix}}
\Big]\Delta E_{q\beta}
\;+\;
\Delta E_{p\alpha}
\;=\;
b_{p\alpha},
\end{equation}
where $\mathcal{N}(p)$ is the neighbor set covered by the stencil (typically up to $3\times3\times3$ corner nodes), and $b_{p\alpha}$ corresponds to the RHS terms in \eqref{eq:increment_linear_system} sampled on corner/center nodes.

\subsection{Boundary conditions in increment form}
Rows corresponding to boundary nodes are replaced by:
\begin{equation}
\Delta E_{p\alpha} = 0,
\end{equation}
implemented as a unit diagonal with no couplings.

\subsection{Post-solve field updates}
After solving \eqref{eq:increment_linear_system}:
\begin{align}
\mathbf{E}^{n+\theta} &= \mathbf{E}^n + \Delta\mathbf{E},\\
\mathbf{B}^{n+1} &= \mathbf{B}^n - c\Delta t\,\nabla\times \mathbf{E}^{n+\theta},\\
\mathbf{E}^{n+1} &= \frac{\mathbf{E}^{n+\theta} - (1-\theta)\mathbf{E}^n}{\theta}.
\end{align}

\subsection{Unit-conversion consistency (legacy vs semantic RHS)}
If the code stores fields in code units, but assembles the linear system in physical (or mixed) units, then the sampling operation for $\mathbf{E}$ and $\mathbf{B}$ must apply $E_{\mathrm{conv}}$ and $B_{\mathrm{conv}}$ consistently. Equivalently, the stencil coefficients must absorb these conversion factors. A mismatch causes the new semantic RHS to deviate from the legacy RHS when $E_{\mathrm{conv}}\neq 1$ and/or $B_{\mathrm{conv}}\neq 1$.

%=========================================================
% Focused “physics ↔ discretization” derivation (matches code signs/scales)
%=========================================================

\section{Focused Physics $\leftrightarrow$ Discretization Derivation (Code-Matched)}

\subsection{Starting point: implicit current response (ECSIM)}
In Gaussian units (consistent with $4\pi$ factors), Ampère–Maxwell reads
\begin{equation}
\frac{\partial \mathbf{E}}{\partial t} \;=\; c\,\nabla\times \mathbf{B} \;-\; 4\pi\,\mathbf{J}.
\end{equation}
ECSIM uses a linearized implicit current model at the solve time level:
\begin{equation}
\mathbf{J}^{n+\theta} \;\approx\; \hat{\mathbf{J}}^{\,n} \;+\; M\,\mathbf{E}^{n+\theta},
\end{equation}
where $\hat{\mathbf{J}}^{\,n}$ is the (field-independent) predictor current assembled in
\texttt{UpdateJMassMatrix()}, and $M$ is the mass matrix stored on corner nodes.

\subsection{Eliminating \texorpdfstring{$\mathbf{B}^{n+\theta}$}{B^{n+θ}} yields a curl--curl operator}
Using Faraday’s law with $\theta$-centering,
\begin{equation}
\mathbf{B}^{n+1} = \mathbf{B}^{n} - c\,\Delta t\,\nabla\times \mathbf{E}^{n+\theta},
\end{equation}
one may write
\begin{equation}
\mathbf{B}^{n+\theta} = \mathbf{B}^{n} - \theta\,c\,\Delta t\,\nabla\times \mathbf{E}^{n+\theta}.
\end{equation}
Insert this into the $\theta$-scheme for Ampère:
\begin{equation}
\mathbf{E}^{n+\theta} = \mathbf{E}^{n} + \theta\,\Delta t\left(c\,\nabla\times \mathbf{B}^{n+\theta} - 4\pi\,\mathbf{J}^{n+\theta}\right),
\end{equation}
and substitute $\mathbf{J}^{n+\theta}\approx \hat{\mathbf{J}}^{\,n}+M\mathbf{E}^{n+\theta}$ to obtain
\begin{equation}
\mathbf{E}^{n+\theta} - \mathbf{E}^{n}
=
\theta c\Delta t\,\nabla\times \mathbf{B}^{n}
-\theta^2(c\Delta t)^2\,\nabla\times\nabla\times \mathbf{E}^{n+\theta}
-4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}
-4\pi\theta\Delta t\,M\mathbf{E}^{n+\theta}.
\end{equation}

\subsection{Increment form: \texorpdfstring{$\Delta\mathbf{E}=\mathbf{E}^{n+\theta}-\mathbf{E}^n$}{ΔE = E^{n+θ}-E^n}}
Let $\Delta\mathbf{E}\equiv \mathbf{E}^{n+\theta}-\mathbf{E}^{n}$. Then
\begin{equation}
\Delta\mathbf{E}
=
\theta c\Delta t\,\nabla\times \mathbf{B}^{n}
-\theta^2(c\Delta t)^2\,\nabla\times\nabla\times (\mathbf{E}^{n}+\Delta\mathbf{E})
-4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}
-4\pi\theta\Delta t\,M(\mathbf{E}^{n}+\Delta\mathbf{E}).
\end{equation}
Bring all $\Delta\mathbf{E}$ terms to the left:
\begin{equation}
\Big[
I
+\theta^2(c\Delta t)^2\,\nabla\times\nabla\times
+4\pi\theta\Delta t\,M
\Big]\Delta\mathbf{E}
=
\theta c\Delta t\,\nabla\times \mathbf{B}^{n}
-4\pi\theta\Delta t\,\hat{\mathbf{J}}^{\,n}
-\theta^2(c\Delta t)^2\,\nabla\times\nabla\times \mathbf{E}^{n}
-4\pi\theta\Delta t\,M\mathbf{E}^{n}.
\label{eq:increment_system_continuous}
\end{equation}

\subsection{Mapping to the exact discrete operator used in \texttt{GetStencil()}}
The code discretizes the curl--curl term using
\begin{equation}
\nabla\times\nabla\times\mathbf{E} \;=\; \nabla(\nabla\cdot\mathbf{E})-\nabla^2\mathbf{E}.
\end{equation}
Define the code factors (exactly as in \texttt{init\_metrics\_and\_time\_factors()}):
\begin{equation}
\texttt{coeff[d]}=\frac{\theta\,\texttt{cDt}}{\Delta x_d},\qquad
\texttt{coeffSqr[d]}=\texttt{coeff[d]}^2,\qquad
\texttt{coeff4[d]}=\frac{1}{4}\texttt{coeff[d]}.
\end{equation}
Then the LHS parameter part assembled for the increment is:
\begin{align}
\textbf{(i) }&I:\quad A^{(\mathrm{param})}_{pp} \mathrel{+}= 1,\\
\textbf{(ii) }&-\nabla^2:\quad A^{(\mathrm{param})} \mathrel{-}= a^{(\nabla^2)}_{t}\;\texttt{coeffSqr[idim]},\\
\textbf{(iii) }&+\nabla\nabla\cdot:\quad
A^{(\mathrm{param})} \mathrel{+}= a^{(\nabla\nabla\cdot)}_{t}\;\texttt{coeff[p]}\;\texttt{coeff[q]},
\end{align}
with the grad--div coefficient blended between two stencil families:
\begin{equation}
a^{(\nabla\nabla\cdot)}_{t}
=
(1-\texttt{corrCoeff})\,a^{(0)}_{t}
+\texttt{corrCoeff}\,a^{(375)}_{t}.
\end{equation}
The mass-matrix LHS term is \emph{not} added into $A^{(\mathrm{param})}$; instead,
each entry stores a pointer to $M_{pq}$, and the numeric matrix is formed by:
\begin{equation}
A_{ij} = A^{(\mathrm{param})}_{ij} + \left(4\pi\,\Delta t\,\theta\right)\,M_{ij},
\qquad
4\pi\Delta t\theta = 4\cdot\texttt{Pi}\cdot\texttt{dtTotal}\cdot\texttt{theta}.
\end{equation}

\subsection{Mapping to the exact discrete RHS assembled in \texttt{GetStencil()}}
Equation \eqref{eq:increment_system_continuous} implies four RHS blocks. The code constructs each as follows.

\paragraph{1) Curl($B^n$) block}
The discrete curl uses \textbf{center-node} $B$ samples with a $2\times 2$ face average.
For example, for row component $p=x$ (\texttt{iVar==0}),
\begin{equation}
(\nabla\times \mathbf{B})_x \approx \frac{\partial B_z}{\partial y} - \frac{\partial B_y}{\partial z},
\end{equation}
implemented as differences of face-averaged center-node values with coefficients $\pm\texttt{coeff4[d]}$.
Thus the code-level coefficient corresponds to
\begin{equation}
\theta c\Delta t\;\frac{1}{\Delta x_d}
\quad\longleftrightarrow\quad
\texttt{coeff[d]},
\end{equation}
and the face-average introduces the explicit $\tfrac14$ factor (\texttt{coeff4}).

\paragraph{2) Current predictor block $-4\pi\theta\Delta t\,\hat{\mathbf{J}}^n$}
A single \textbf{corner-node} current entry is added with coefficient
\begin{equation}
\alpha_J = -4\pi\,\Delta t\,\theta
\end{equation}
(via \texttt{SetCornerJ(-4*Pi*dtTotal*theta,...)}), sampled from the corner-node electric-field buffer
layout (where $J$ is stored).

\paragraph{3) Old-field curl--curl block $-\theta^2(c\Delta t)^2\,\nabla\times\nabla\times \mathbf{E}^n$}
The code moves the old-field curl--curl to the RHS by adding:
\begin{itemize}
\item \textbf{Plus Laplacian($E^n$):}
\[
+\;a_t\;\texttt{coeffSqr[idim]}\;E^n(\text{neighbor}),
\]
implemented as \texttt{add\_corner\_E\_coeff(..., +st->Data[it].a*coeffSqr[idim])}.
\item \textbf{Minus grad--div($E^n$):}
\[
-\;a_t\;\texttt{coeff[p]}\;\texttt{coeff[q]}\;E^n_q(\text{neighbor}),
\]
implemented as \texttt{add\_corner\_E\_coeff(..., -(1-corrCoeff)*...*coeff[p]*coeff[q])}
and the analogous \texttt{-corrCoeff} term for the \texttt{375} stencil family.
\end{itemize}
Together, this is exactly $-(\nabla\nabla\cdot-\nabla^2 I)\mathbf{E}^n = -(\nabla\times\nabla\times\mathbf{E}^n)$, multiplied by $(\theta c\Delta t)^2$ through the \texttt{coeff} factors.

\paragraph{4) Mass-matrix old-field block $-4\pi\theta\Delta t\,M\mathbf{E}^n$}
The mass-matrix dot-product is moved to the RHS using semantic \textbf{corner-node} entries of type
\texttt{Quantity::MassMatrix}. Each entry evaluates
\begin{equation}
\mathcal{Q}_s = M(\texttt{aux\_index})\;E^n_q(\text{neighbor}),
\end{equation}
and is multiplied by the coefficient
\begin{equation}
\alpha_{ME} = (-4\pi\,\Delta t\,\theta)\;E_{\mathrm{conv}}
\qquad
(\texttt{mmScale = (-4.0*Pi*dtTotal*theta) * E\_conv}).
\end{equation}
(The sampling routine returns $E$ directly from the buffer without applying $E_{\mathrm{conv}}$, hence the explicit $E_{\mathrm{conv}}$ in the coefficient to preserve legacy scaling.)

\subsection{Final discrete linear system (as implemented)}
Let $\Delta E_{p}$ denote the increment unknown at a corner node and component $p$.
The assembled row (for fixed \texttt{iVar}=p) has the form:
\begin{equation}
\sum_{q\in\{x,y,z\}}\sum_{\alpha\in\mathcal{N}}
\Big[
K^{(\mathrm{curlcurl})}_{p q}(\alpha)
\;+\;
4\pi\Delta t\theta\;M_{p q}(\alpha)
\Big]\Delta E_q(\alpha)
\;+\;
\Delta E_p(\mathbf{0})
=
b_p,
\end{equation}
where:
\begin{itemize}
\item $K^{(\mathrm{curlcurl})}$ is the parameter-assembled discrete operator
$(-\nabla^2+\nabla\nabla\cdot)$ scaled by \texttt{coeffSqr} and \texttt{coeff[p]*coeff[q]}
(and blended by \texttt{corrCoeff} for the grad--div part),
\item $M_{pq}(\alpha)$ is dereferenced from the support pointer and multiplied by
$4\pi\Delta t\theta$ in \texttt{UpdateMatrixElement},
\item $b_p$ is the sum of the four RHS blocks described above:
curl($B^n$), $-4\pi\theta\Delta t\,\hat{J}^n$, $-\theta^2(c\Delta t)^2\,\nabla\times\nabla\times E^n$,
and $-4\pi\theta\Delta t\,M E^n$ (with the code’s explicit $E_{\mathrm{conv}}$ scaling).
\end{itemize}

\subsection{Boundary conditions}
Boundary nodes enforce
\begin{equation}
\Delta \mathbf{E} = \mathbf{0}
\end{equation}
by replacing the row with a unit diagonal and no couplings.

