head	1.1;
access;
symbols;
locks
	vtenishe:1.1; strict;
comment	@ * @;


1.1
date	2012.09.27.18.58.11;	author vtenishe;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@//========================================================================
//$Id$
//========================================================================

#ifndef _MARS_EXOSPEHRE_
#define _MARS_EXOSPEHRE_


#include <stdio.h>
#include <stdlib.h>
#include <vector>
#include <string>
#include <list>
#include <math.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <iostream>
#include <iostream>
#include <fstream>
#include <time.h>
#include <dirent.h>

#include "pic.h"

#include "specfunc.h"
#include "ifileopr.h"
#include "MTGCM.h"

#include "quadrature.h"

//Background atmosphere from J. Fox
#include "MarsBackgroundAtmosphereFox.h"

//the forward scattering cross section
#include "Kharchenko-2000-fig-3.h"

/*
//List of types of O2+ DR coefficients
#define Hodges 0
#define Mehr 1
#define Peverall 2

#define DR Mehr
*/
//List of types of CO+ DR coefficients
#define Rosen 0
#define Cloutier 1
#define Mitchell 2

#define DR Rosen

using namespace std;

const double massO=26.56E-27; 
const double massC=19.93E-27;
const double massO2=2*26.56E-27;
const double massCO=massC+massO;
const double k=1.3806503E-23;


//the offset in the cells' data to the local maximum of the cells' background densit
extern int maxLocalBackdroundDensityOffset;
 
namespace newMars {
extern cDataSetMTGCM Te;
extern cDataSetMTGCM Ti,Tn,O,CO2,O2p,Un,Vn,Wn,COp,CO,E;

//offsets of the model sampled data
extern int maxLocalCellOxigenProductionRateOffset,minLocalCellOxigenProductionRateOffset,minLocalBackdroundDensityOffset;
extern int sampledLocalInjectionRateOffset;
extern double *SampledEscapeRate;

//int maxLocalBackdroundDensityOffset;

//read the forward collision cross section data
//extern cDiffCrossSection ForwardCollisionCrossSection;


//request sampling buffer
int RequestSamplingData(int);
int RequestStaticCellData(int);

inline void ReadMTGCM() {
			
		/*const char directory[]="EH";
		DIR *pdir;
		struct dirent *pent;
		pdir=opendir(".");
		pent=chdir(directory);*/
				
		Te.PlanetRadius=3376.2E3;
		Te.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_CONSTANT_;
		Te.ReadDataFile("Te.h");
		
		Tn.PlanetRadius=3376.2E3;
		Tn.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_CONSTANT_;
		Tn.ReadDataFile("Tn.h");
				
		Ti.PlanetRadius=3376.2E3;
		Ti.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_CONSTANT_;
		Ti.ReadDataFile("Ti.h");
		
		O2p.PlanetRadius=3376.2E3;
		O2p.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		O2p.ReadDataFile("O2p.h");
				
		E.PlanetRadius=3376.2E3;
		E.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		E.ReadDataFile("E.h");
		
		O.PlanetRadius=3376.2E3;
		O.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		O.ReadDataFile("O.h");
		
		CO.PlanetRadius=3376.2E3;
		CO.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		CO.ReadDataFile("CO.h");
		
		CO2.PlanetRadius=3376.2E3;
		CO2.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		CO2.ReadDataFile("CO2.h");
		
		Un.PlanetRadius=3376.2E3;
		Un.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		Un.ReadDataFile("Un.h");
		
		Vn.PlanetRadius=3376.2E3;
		Vn.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		Vn.ReadDataFile("Vn.h");
		
		Wn.PlanetRadius=3376.2E3;
		Wn.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		Wn.ReadDataFile("Wn.h");
		
		COp.PlanetRadius=3376.2E3;
		COp.OutsideDomainInterpolationMode=_MTGCM_INTERPOLATION_MODE_VERTICAL_SCALE_HIGHT__FORCE_POSITIVE_;
		COp.ReadDataFile("COp.h");

		//pent=chdir("..");
	
}
	
  //the total acceleration of the particles in the exosphere
  void TotalParticleAcceleration(double *accl,int spec,long int ptr,double *x,double *v,cTreeNodeAMR<PIC::Mesh::cDataBlockAMR>  *startNode);

	//print on the screen sampled total escape rate
	void SampleModelData();

  void OutputSampledModelData(int DataOutputFileNumber);

	//process particles that leaves the boundary of the computational domain: calcualte the escape rate
	int ProcessOutsideDomainParticles(long int ptr,cTreeNodeAMR<PIC::Mesh::cDataBlockAMR>  *startNode);

	//init the model
  inline void Init_AfterParser() {
    int i,iAngle;
    double da;


    //read the forward collision cross section data
//    ForwardCollisionCrossSection.Set_ScatteringAngleMinimumIntegratedValue_Degrees(1.5);


//    ForwardCollisionCrossSection.AddProfile(0.03*eV2J,_KHANCHERKO_2000__0_03EV_DATA_LENGTH_,_KHANCHERKO_2000__0_03EV_DATA_);
//    ForwardCollisionCrossSection.AddProfile(0.3*eV2J,_KHANCHERKO_2000__0_3EV_DATA_LENGTH_,_KHANCHERKO_2000__0_3EV_DATA_);

//    ForwardCollisionCrossSection.AddProfile(3*eV2J,_KHANCHERKO_2000__3EV_DATA_LENGTH_,_KHANCHERKO_2000__3EV_DATA_);


    ForwardCollisionCrossSection.AddProfile(3*eV2J,_FOX_LENGTH_,_FOX_DATA_);

//    ForwardCollisionCrossSection.AddProfile(3.1*eV2J,_KHANCHERKO_LENGTH_,_KHANCHERKO_DATA_);


    ForwardCollisionCrossSection.InitInternalTable();
    ForwardCollisionCrossSection.PrintCrossSectionPlot();

    ReadMTGCM();

    //request sampling buffer for the Mars model
    PIC::IndividualModelSampling::RequestSamplingData.push_back(RequestSamplingData);
    PIC::IndividualModelSampling::RequestStaticCellData.push_back(RequestStaticCellData);

    //init the buffer for sampling the escape rate
    SampledEscapeRate=new double[PIC::nTotalSpecies];
    for (i=0;i<PIC::nTotalSpecies;i++) SampledEscapeRate[i]=0.0;

    //set up the functions that calculated and output the escape rate
    PIC::Mover::ProcessOutsideDomainParticles=ProcessOutsideDomainParticles;

    //set up the model sampling procedure
    PIC::Sampling::ExternalSamplingLocalVariables::RegisterSamplingRoutine(SampleModelData,OutputSampledModelData);

    //init the procedure for calculation of the forward scatternig cross section
    TotalIntegratedForwardScatteringCrossSection=0.0;

    for (iAngle=0;iAngle<nForwardScatteringCrossSectionLines;iAngle++) {
      ForwardScatteringCrossSectionData[iAngle].Angle*=Pi/180.0;
      ForwardScatteringCrossSectionData[iAngle].DifferentialCrossSection*=1.0E-16*1.0E-4;
    }

    for (i=0;i<CumulativeDistributionMaskList;i++) CumulativeDistributionMask[i]=-1;

    for (iAngle=0;iAngle<nForwardScatteringCrossSectionLines-1;iAngle++) {
      da=ForwardScatteringCrossSectionData[iAngle+1].Angle-ForwardScatteringCrossSectionData[iAngle].Angle;

      ForwardScatteringCrossSectionData[iAngle].deltaCumulativeDistributionFunction=2.0*Pi* 0.5*da*(
          ForwardScatteringCrossSectionData[iAngle].DifferentialCrossSection*sin(ForwardScatteringCrossSectionData[iAngle].Angle)+
          ForwardScatteringCrossSectionData[iAngle+1].DifferentialCrossSection*sin(ForwardScatteringCrossSectionData[iAngle+1].Angle));

      ForwardScatteringCrossSectionData[iAngle].CumulativeDistributionFunction=TotalIntegratedForwardScatteringCrossSection;
      TotalIntegratedForwardScatteringCrossSection+=ForwardScatteringCrossSectionData[iAngle].deltaCumulativeDistributionFunction;
    }

    //normalize the cumulative distribution function; init the cumulative distribution mask
    for (iAngle=0;iAngle<nForwardScatteringCrossSectionLines;iAngle++) {
      ForwardScatteringCrossSectionData[iAngle].CumulativeDistributionFunction/=TotalIntegratedForwardScatteringCrossSection;
      ForwardScatteringCrossSectionData[iAngle].deltaCumulativeDistributionFunction/=TotalIntegratedForwardScatteringCrossSection;

      i=(int)(CumulativeDistributionMaskList*ForwardScatteringCrossSectionData[iAngle].CumulativeDistributionFunction);
      if (CumulativeDistributionMask[i]==-1) CumulativeDistributionMask[i]=iAngle;
    }

    //fill all possible hole in the cumulative distribution mask
    for (i=1;i<CumulativeDistributionMaskList;i++) if (CumulativeDistributionMask[i]==-1) {
      for (int j=i-1;j>=0;j--) if (CumulativeDistributionMask[j]!=-1) {
        CumulativeDistributionMask[i]=CumulativeDistributionMask[j];
        break;
      }
    }

  }
	
	inline double ProductionRateCaluclation(double *x) {
		double production_rate=0.0;

		if (x[0]*x[0]+x[1]*x[1]+x[2]*x[2]<pow(O.PlanetRadius+O.minAltitude,2)) return 0.0;
/*
		#if DR == Hodges //Hodges [2000]
		production_rate=1.6E-7*pow(300/Te.Interpolate(x),0.55)*O2p.Interpolate(x)*E.Interpolate(x); 
		#endif
		#if DR == Mehr //Mehr and Biondi [1969]
		if (Te.Interpolate(x)<=1200.0) {production_rate=1.95E-7*pow(300/Te.Interpolate(x),0.7)*O2p.Interpolate(x)*E.Interpolate(x);}
		else if (Te.Interpolate(x)>1200.0) {production_rate=0.75E-7*pow(1200/Te.Interpolate(x),0.56)*O2p.Interpolate(x)*E.Interpolate(x);}
		#endif
		#if DR == Peverall //Peverall [2001]
		production_rate=2.4E-7*pow(300/Te.Interpolate(x),0.7)*O2p.Interpolate(x)*E.Interpolate(x);
		#endif
*/	
		#if DR == Rosen //Rosen [1998]
		production_rate=2.75E-7*pow(300/Te.Interpolate(x),0.55)*COp.Interpolate(x)*E.Interpolate(x);
		#endif
		#if DR == Cloutier //Cloutier and Daniell [1979]
		production_rate=6.47E-7*pow(300/Te.Interpolate(x),0.53)*COp.Interpolate(x)*E.Interpolate(x);
		#endif
		#if DR == Mitchell //Mitchell and Hus [1985]
		production_rate=2.0E-7*pow(300/Te.Interpolate(x),0.48)*COp.Interpolate(x)*E.Interpolate(x);
		#endif
	
    return production_rate*1.0e6;
	}





	void ProductionRateCaluclation(bool *InjectionFlag,double *Rate, int iCellIndex,int jCellIndex,int kCellIndex,PIC::Mesh::cDataCenterNode *cell, cTreeNodeAMR<PIC::Mesh::cDataBlockAMR> *node);
	


  //print the model parameters
  void PrintVariableList(FILE* fout,int DataSetNumber);
  void PrintData(FILE* fout,int DataSetNumber,CMPI_channel *pipe,int CenterNodeThread,PIC::Mesh::cDataCenterNode *CenterNode);
  void Interpolate(PIC::Mesh::cDataCenterNode** InterpolationList,double *InterpolationCoeficients,int nInterpolationCoeficients,PIC::Mesh::cDataCenterNode *CenterNode);


	///////////////////////////////////

	inline void ProductionRateSliceMap() {
		
		
		double x[3],production=0.0,O2pdensity=0.0,Edensity=0.0,Etemp=0.0,Tneutral=0.0;
		
		const int nPoints=300;
		const double R=190E3+Te.PlanetRadius; //determine the altitude of interest
		const double dLon=2.0*Pi/(nPoints-1),dLat=Pi/(nPoints-1);
		
		FILE *fout=fopen("Production_rate.dat","w");
		fprintf(fout,"VARIABLES = \"Lon\", \"Lat\", \"Production Rate\",\"O2+ Density\",\"electron Density\",\"e temp\",\"neutral temp\"\nZONE I=%i, J=%i, DATAPACKING=POINT\n",nPoints,nPoints);
		
		int i,j;
		double Lon,Lat;
		
		for (i=0;i<nPoints;i++) {
			Lat=-Pi/2.0+i*dLat;
			
			for (j=0;j<nPoints;j++) {
				Lon=j*dLon;
				
				x[0]=R*cos(Lat)*cos(Lon);
				x[1]=R*cos(Lat)*sin(Lon);
				x[2]=R*sin(Lat);
								
				production=ProductionRateCaluclation(x);
				O2pdensity=O2p.Interpolate(x);
				Tneutral=Tn.Interpolate(x);
				Edensity=E.Interpolate(x);
				Etemp=Te.Interpolate(x);
				
				if (production>1E10) {
					std::cout << __LINE__ << __FILE__ << std::endl;
				}
								
				fprintf(fout,"%e  %e  %e  %e  %e  %e  %e\n",Lon,Lat,production,O2pdensity,Edensity,Etemp,Tneutral);
								
			}
		}
		fclose(fout);
	}
	/*	
	double maxvalue(double array[]) {
		int length=array.length()l; //size of array
		int max=array[0]; //max=1st element
		
		for (int i=1;i<length;i++) {
			if (array[i]>max) max=array[i];}
		return max;
	}*/
	
	/*void CartesianToSpherical(double *Spherical, double *k) {
		double X=k[0],Y=k[1],Z=k[2];
		double R=sqrt(X*X+Y*Y+Z*Z);
		double LAT=asin(Z/R)/Pi*180.0;
		double LONG=0.0;
		if (Y>0) {
			if (X>0) {LONG=atan(Y/X)/Pi*180.0;}
			else if (X<0) {LONG=180.0+atan(Y/X)/Pi*180.0;}
			else if (X==0) {LONG=90.0;}
		}
		else if (Y<0) {
			if (X>0) {LONG=-atan(-Y/X)/Pi*180.0;}
			else if (X<0) {LONG=-(180.0+atan(-Y/X)/Pi*180.0);}
			else if (X==0) {LONG=-90.0;}
		}
		else if (Y==0) {
			if (X>0) {LONG=0.0;}
			if (X<0) {LONG=180.0;}
		}
		Spherical[0]=R;
		Spherical[1]=LONG;
		Spherical[2]=LAT;
	}*/
	
	inline void BGMeanFlowVelocity(double *velocity, double *k) {
		for (int idim=0;idim<3;idim++) velocity[idim]=0.0;
        /*#if WindsAndRotation==on
		double RotationSpeed=240.0;
		double sph[3];
		CartesianToSpherical(sph,x);
		double R=y[0],LON=y[1],LAT=y[2];
		double Z=Un.Interpolate(x)+RotationSpeed*cos(LAT/180.0*Pi);
		double M=Vn.Interpolate(x);
		double V=Wn.Interpolate(x);
		vel[0]=V*cos(LAT/180.0*Pi)*cos(LON/180.0*Pi)-M*sin(LAT/180.0*Pi)*cos(LON/180.0*Pi)-Z*sin(LON/180.0*Pi);
		vel[1]=V*cos(LAT/180.0*Pi)*sin(LON/180.0*Pi)-M*sin(LAT/180.0*Pi)*sin(LON/180.0*Pi)+Z*cos(LON/180.0*Pi);
		vel[2]=V*sin(LAT/180.0*Pi)+M*cos(LAT/180.0*Pi);		
		#endif*/
	}
	
namespace HotOxygen {

		//KE = (eV from each channel) * (eV to J) 
		/*
		const float KineticEnergy1=0.83*1.60217653E-19;
		const float KineticEnergy2=3.05*1.60217653E-19;
		const float KineticEnergy3=5.02*1.60217653E-19;
		const float KineticEnergy4=6.98*1.60217653E-19;*/

		const float KineticEnergy1=2.90*1.60217653E-19;
		const float KineticEnergy2=1.64*1.60217653E-19;
		const float KineticEnergy3=0.94*1.60217653E-19;
		
//	void HotOProduction() {
		 long int HotOProduction(int iCellIndex,int jCellIndex,int kCellIndex,PIC::Mesh::cDataCenterNode *cell, cTreeNodeAMR<PIC::Mesh::cDataBlockAMR> *node);
  	 double LocalTimeStep(int spec,bool& TimeStepLimitationImposed, cTreeNodeAMR<PIC::Mesh::cDataBlockAMR> *node);


}}



#endif




@
